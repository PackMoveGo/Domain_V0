/**
 * Unified API Service for PackMoveGo Application
 * 
 * This module provides centralized API functionality with:
 * - Environment-aware configuration from vite.config.js
 * - JWT authentication for cross-domain access
 * - Proper error handling and status codes
 * - CORS bearer token handling
 * 
 * Features:
 * - Unified API client for all endpoints
 * - JWT token management for client.packmovego.com
 * - Environment-based configuration
 * - Proper status codes for API-dependent services
 */

import { handleApiError } from '../util/apiErrorHandler';
import { apiCache } from '../util/apiCache';

// =============================================================================
// API FAILURE MODAL MANAGEMENT
// =============================================================================

// =============================================================================
// API CONFIGURATION FUNCTIONS
// =============================================================================

// API configuration functions (moved from config/api)
const getApiKey = (): string => {
  // Get API key from environment variables
  const getEnvVar = (key: string, fallback?: string): string => {
    // Priority 1: process.env (for SSR and Node.js)
    if (typeof process !== 'undefined' && process.env && process.env[key]) {
      return process.env[key];
    }
    
    // Priority 2: Vite global variables (from vite.config.js define)
    const globalKey = `__${key.replace('VITE_', '')}__`;
    if (typeof window !== 'undefined' && (window as any)[globalKey]) {
      return (window as any)[globalKey];
    }
    
    // Priority 3: Check for Vite environment variables in window object
    if (typeof window !== 'undefined' && (window as any).__VITE_ENV__ && (window as any).__VITE_ENV__[key]) {
      return (window as any).__VITE_ENV__[key];
    }
    
    // Return fallback or empty string
    return fallback || '';
  };

  return getEnvVar('VITE_API_KEY_FRONTEND') || '';
};

const getSigninHost = (): string => {
  // Will be updated after ENV_CONFIG is available
  return 'https://localhost:3000/signin';
};

// =============================================================================
// API CALL DEDUPLICATION
// =============================================================================

// Global request deduplication cache
const pendingRequests = new Map<string, Promise<any>>();

// Rate limiting cache
const requestTimestamps = new Map<string, number>();
const MIN_REQUEST_INTERVAL = 1000; // 1 second between identical requests

const getRequestKey = (endpoint: string, options?: RequestInit): string => {
  const method = options?.method || 'GET';
  const body = options?.body ? JSON.stringify(options.body) : '';
  return `${method}:${endpoint}:${body}`;
};

// Check if request should be throttled
const shouldThrottleRequest = (endpoint: string): boolean => {
  const now = Date.now();
  const lastRequestTime = requestTimestamps.get(endpoint) || 0;
  
  if (now - lastRequestTime < MIN_REQUEST_INTERVAL) {
    return true;
  }
  
  requestTimestamps.set(endpoint, now);
  return false;
};

// =============================================================================
// ENVIRONMENT CONFIGURATION
// =============================================================================
// Load configuration from Vite environment variables following ENVIRONMENT_SETUP.md

const getEnvironmentConfig = () => {
  // Get environment variables from Vite's import.meta.env (primary source)
  const getEnvVar = (key: string, fallback?: string): string => {
    // Priority 1: process.env (for SSR and Node.js)
    if (typeof process !== 'undefined' && process.env && process.env[key]) {
      return process.env[key];
    }
    
    // Priority 2: Vite global variables (from vite.config.js define)
    const globalKey = `__${key.replace('VITE_', '')}__`;
    if (typeof window !== 'undefined' && (window as any)[globalKey]) {
      return (window as any)[globalKey];
    }
    
    // Priority 3: Check for Vite environment variables in window object
    if (typeof window !== 'undefined' && (window as any).__VITE_ENV__ && (window as any).__VITE_ENV__[key]) {
      return (window as any).__VITE_ENV__[key];
    }
    
    // Return fallback or empty string
    return fallback || '';
  };

  // Get boolean environment variable
  const getBoolEnvVar = (key: string): boolean => {
    const value = getEnvVar(key);
    if (value === '') return false;
    return value === 'true' || value === '1';
  };

  // Get number environment variable
  const getNumberEnvVar = (key: string): number => {
    const value = getEnvVar(key);
    if (value === '') return 0;
    const parsed = parseInt(value, 10);
    return isNaN(parsed) ? 0 : parsed;
  };

  // Build configuration object using environment variables
  const config = {
    API_URL: getEnvVar('VITE_API_URL') || getEnvVar('VITE_API_BASE_URL') || 'https://localhost:3000',
    SKIP_BACKEND_CHECK: getBoolEnvVar('VITE_SKIP_BACKEND_CHECK'),
    DEV_MODE: getEnvVar('VITE_DEV_MODE'),
    APP_NAME: getEnvVar('VITE_APP_NAME'),
    APP_VERSION: getEnvVar('VITE_APP_VERSION'),
    PORT: getEnvVar('VITE_PORT'),
    DEV_HTTPS: getBoolEnvVar('VITE_DEV_HTTPS'),
    IS_SSR: getBoolEnvVar('VITE_IS_SSR'),
    MODE: getEnvVar('VITE_MODE'),
    ENABLE_DEV_TOOLS: getBoolEnvVar('ENABLE_DEV_TOOLS'),
    REDUCE_LOGGING: getBoolEnvVar('VITE_REDUCE_LOGGING'),
    API_TIMEOUT: getNumberEnvVar('VITE_API_TIMEOUT'),
    API_RETRY_ATTEMPTS: getNumberEnvVar('VITE_API_RETRY_ATTEMPTS'),
    CACHE_ENABLED: getBoolEnvVar('VITE_CACHE_ENABLED'),
    CACHE_TTL: getNumberEnvVar('VITE_CACHE_TTL'),
    CACHE_MAX_SIZE: getNumberEnvVar('VITE_CACHE_MAX_SIZE'),
    API_KEY_FRONTEND: getApiKey()
  };

  // Ensure API URL has protocol
  if (config.API_URL && !/^https?:\/\//i.test(config.API_URL)) {
    config.API_URL = `http://${config.API_URL}`;
  }

  return config;
};

const ENV_CONFIG = getEnvironmentConfig();

// Update getSigninHost now that ENV_CONFIG is available
const updateSigninHost = (): string => {
  return ENV_CONFIG.API_URL.replace('/api', '/signin') || 'https://localhost:3000/signin';
};

// Development guard: force use real API in development mode
if (typeof window !== 'undefined') {
  const isDev = ENV_CONFIG.DEV_MODE === 'development' || (process.env && process.env.NODE_ENV === 'development');
}


// =============================================================================
// JWT AUTHENTICATION MANAGEMENT
// =============================================================================

interface JWTToken {
  token: string;
  expiresAt: number;
  user?: {
    id: string;
    email: string;
    name: string;
  };
}

class JWTAuthManager {
  private static instance: JWTAuthManager;
  private token: JWTToken | null = null;

  private constructor() {
    this.loadStoredToken();
  }

  static getInstance(): JWTAuthManager {
    if (!JWTAuthManager.instance) {
      JWTAuthManager.instance = new JWTAuthManager();
    }
    return JWTAuthManager.instance;
  }

  private loadStoredToken(): void {
    try {
      // Check if we're in a browser environment
      if (typeof window !== 'undefined' && window.localStorage) {
        const stored = localStorage.getItem('packmovego_jwt_token');
        if (stored) {
          this.token = JSON.parse(stored);
          // Check if token is expired
          if (this.token && this.token.expiresAt < Date.now()) {
            this.clearToken();
          }
        }
      }
    } catch (error) {
      console.warn('Failed to load stored JWT token:', error);
      this.clearToken();
    }
  }

  setToken(tokenData: JWTToken): void {
    this.token = tokenData;
    try {
      // Check if we're in a browser environment
      if (typeof window !== 'undefined' && window.localStorage) {
        localStorage.setItem('packmovego_jwt_token', JSON.stringify(tokenData));
      }
    } catch (error) {
      console.warn('Failed to store JWT token:', error);
    }
  }

  getToken(): string | null {
    if (!this.token || this.token.expiresAt < Date.now()) {
      this.clearToken();
      return null;
    }
    return this.token.token;
  }

  getUser(): any {
    return this.token?.user || null;
  }

  isAuthenticated(): boolean {
    return this.getToken() !== null;
  }

  clearToken(): void {
    this.token = null;
    try {
      // Check if we're in a browser environment
      if (typeof window !== 'undefined' && window.localStorage) {
        localStorage.removeItem('packmovego_jwt_token');
      }
    } catch (error) {
      console.warn('Failed to clear JWT token:', error);
    }
  }

  getAuthHeaders(): Record<string, string> {
    const token = this.getToken();
    return token ? { 'Authorization': `Bearer ${token}` } : {};
  }

  needsRefresh(): boolean {
    if (!this.token) return false;
    // Refresh if token expires in less than 5 minutes
    return this.token.expiresAt - Date.now() < 5 * 60 * 1000;
  }
}

// =============================================================================
// API ENDPOINTS CONFIGURATION
// =============================================================================

export const API_ENDPOINTS = {
  // Authentication endpoints
  AUTH: {
    LOGIN: '/auth/login',
    LOGOUT: '/auth/logout',
    STATUS: '/auth/status',
    REFRESH: '/auth/refresh'
  },
  
  // Public content endpoints (no authentication required)
  PUBLIC: {
    NAV: '/public/nav',
    SERVICES: '/public/services',
    HEALTH: '/public/health',
    ABOUT: '/public/about',
    CONTACT: '/public/contact',
    REFERRAL: '/public/referral',
    BLOG: '/public/blog',
    REVIEWS: '/public/reviews',
    LOCATIONS: '/public/locations',
    SUPPLIES: '/public/supplies',
    TESTIMONIALS: '/public/testimonials',
    SERVICE_AREAS: '/v0/serviceAreas'
  },
  
  // Private content endpoints (require authentication)
  PRIVATE: {
    NAV: '/v0/nav',
    SERVICES: '/v0/services',
    HEALTH: '/health',
    ABOUT: '/v0/about',
    CONTACT: '/v0/contact',
    REFERRAL: '/v0/referral',
    BLOG: '/v0/blog',
    REVIEWS: '/v0/reviews',
    LOCATIONS: '/v0/locations',
    SUPPLIES: '/v0/supplies',
    TESTIMONIALS: '/v0/testimonials'
  }
};

// =============================================================================
// API CLIENT CLASS
// =============================================================================

export class APIsw {
  private static instance: APIsw;
  private jwtAuth: JWTAuthManager;
  private isDevMode: boolean;
  private modalState: {
    isVisible: boolean;
    failedEndpoints: string[];
    is503Error: boolean;
    onClose: (() => void) | null;
  } = {
    isVisible: false,
    failedEndpoints: [],
    is503Error: false,
    onClose: null
  };
  private modalStateListeners: Set<() => void> = new Set();
  
  // Track API calls for each page
  private pageApiCalls: string[] = [];
  private currentPageName: string = '';
  
  // Cookie consent state
  private isApiBlocked: boolean = false;
  
  // Health gate state
  private healthGateFailed: boolean = false;
  private healthGateChecked: boolean = false;

  private constructor() {
    this.jwtAuth = JWTAuthManager.getInstance();
    this.isDevMode = ENV_CONFIG.DEV_MODE === 'development';
    
    if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
      console.log('üîß APIsw initialized with config:', {
        API_URL: ENV_CONFIG.API_URL,
        SKIP_BACKEND_CHECK: ENV_CONFIG.SKIP_BACKEND_CHECK,
        DEV_MODE: ENV_CONFIG.DEV_MODE,
        PORT: ENV_CONFIG.PORT,
        IS_SSR: ENV_CONFIG.IS_SSR,
        MODE: ENV_CONFIG.MODE,
        ENABLE_DEV_TOOLS: ENV_CONFIG.ENABLE_DEV_TOOLS,
        API_TIMEOUT: ENV_CONFIG.API_TIMEOUT,
        CACHE_ENABLED: ENV_CONFIG.CACHE_ENABLED
      });
    }
  }

  static getInstance(): APIsw {
    if (!APIsw.instance) {
      APIsw.instance = new APIsw();
    }
    return APIsw.instance;
  }

  // =================================================================
  // API BLOCKING METHODS
  // =================================================================

  /**
   * Set API blocking state based on cookie consent
   */
  setApiBlocked(isBlocked: boolean): void {
    this.isApiBlocked = isBlocked;
    if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
      console.log(`üö´ API blocking state changed: ${isBlocked ? 'BLOCKED' : 'ALLOWED'}`);
    }
  }

  /**
   * Get current API blocking state
   */
  getApiBlocked(): boolean {
    return this.isApiBlocked;
  }

  // =================================================================
  // HEALTH GATE METHODS
  // =================================================================

  /**
   * Check health gate - if health fails, block all subsequent API calls
   */
  private async checkHealthGate(): Promise<boolean> {
    // If we've already checked and failed, don't check again
    if (this.healthGateChecked && this.healthGateFailed) {
      return false;
    }

    // If we've already checked and passed, allow calls
    if (this.healthGateChecked && !this.healthGateFailed) {
      return true;
    }

    try {
      console.log('üè• [HEALTH-GATE] Checking health before allowing API calls...');
      await this.checkHealth();
      this.healthGateChecked = true;
      this.healthGateFailed = false;
      console.log('‚úÖ [HEALTH-GATE] Health check passed - API calls allowed');
      return true;
    } catch (error) {
      console.error('‚ùå [HEALTH-GATE] Health check failed - blocking all API calls:', error);
      this.healthGateChecked = true;
      this.healthGateFailed = true;
      
      // Show modal for all failed routes
      const allRoutes = ['/v0/health', '/v0/nav', '/v0/services', '/v0/testimonials', '/v0/recentMoves', '/auth/status'];
      this.showApiFailureModal(allRoutes, true);
      
      return false;
    }
  }

  /**
   * Reset health gate (call when user retries or navigates to new page)
   */
  resetHealthGate(): void {
    this.healthGateChecked = false;
    this.healthGateFailed = false;
    console.log('üîÑ [HEALTH-GATE] Health gate reset - will check health on next API call');
  }

  // =================================================================
  // CORE API METHODS
  // =================================================================

  async makeRequest<T>(
    endpoint: string,
    options: RequestInit = {},
    requireAuth: boolean = false
  ): Promise<T> {
    return await this.makeRequestInternal<T>(endpoint, options, requireAuth);
  }

  async makeRequestInternal<T>(
    endpoint: string,
    options: RequestInit = {},
    requireAuth: boolean = false
  ): Promise<T> {
    // Check health gate first (except for health endpoint itself)
    if (endpoint !== '/v0/health' && !await this.checkHealthGate()) {
      throw new Error('Health check failed - all API calls blocked');
    }

    // Check if API calls are blocked due to cookie consent
    if (this.isApiBlocked && endpoint !== '/v0/health') {
      throw new Error('API calls blocked due to cookie consent');
    }

    const buildUrl = (base: string, ep: string) => {
      const baseTrimmed = base.replace(/\/+$/, '');
      const epTrimmed = ep.startsWith('/') ? ep : `/${ep}`;
      return `${baseTrimmed}${epTrimmed}`;
    };

    // Use only the correct endpoint - no fallbacks since backend is working
    const url = buildUrl(ENV_CONFIG.API_URL, endpoint);
    
    // Track this API call
    this.trackApiCall(endpoint);

    return await this.executeRequestWithDeduplication<T>(url, endpoint, options, requireAuth);
  }

  private async executeRequestWithDeduplication<T>(
    url: string,
    endpoint: string,
    options: RequestInit,
    requireAuth: boolean
  ): Promise<T> {

    // Request deduplication
    const requestKey = getRequestKey(endpoint, options);
    
    // Check if there's already a pending request for this endpoint
    if (pendingRequests.has(requestKey)) {
      if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
        console.log(`üîÑ Reusing pending request: ${endpoint}`);
      }
      return pendingRequests.get(requestKey) as Promise<T>;
    }

    // Check rate limiting
    if (shouldThrottleRequest(endpoint)) {
      if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
        console.log(`‚è≥ Throttling request to ${endpoint} (rate limited)`);
      }
      // Wait for the minimum interval before making the request
      await new Promise(resolve => setTimeout(resolve, MIN_REQUEST_INTERVAL));
    }

    // Create the actual request
    const requestPromise = this.executeRequest<T>(url, options, requireAuth);
    
    // Store the pending request
    pendingRequests.set(requestKey, requestPromise);

    // Clean up after request completes
    requestPromise.finally(() => {
      pendingRequests.delete(requestKey);
    });

    return requestPromise;
  }

  // Public API request method that doesn't redirect on 503 errors
  async makePublicRequest<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
    return await this.makePublicRequestInternal<T>(endpoint, options);
  }

  async makePublicRequestInternal<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
    // Check health gate first (except for health endpoint itself)
    if (endpoint !== '/v0/health' && !await this.checkHealthGate()) {
      throw new Error('Health check failed - all API calls blocked');
    }

    const buildUrl = (base: string, ep: string) => {
      const baseTrimmed = base.replace(/\/+$/, '');
      const epTrimmed = ep.startsWith('/') ? ep : `/${ep}`;
      return `${baseTrimmed}${epTrimmed}`;
    };

    const url = buildUrl(ENV_CONFIG.API_URL, endpoint);

    // Request deduplication
    const requestKey = getRequestKey(endpoint, options);
    
    // Check if there's already a pending request for this endpoint
    if (pendingRequests.has(requestKey)) {
      if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
        console.log(`üîÑ Reusing pending public request: ${endpoint}`);
      }
      return pendingRequests.get(requestKey) as Promise<T>;
    }

    // Check rate limiting
    if (shouldThrottleRequest(endpoint)) {
      if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
        console.log(`‚è≥ Throttling public request to ${endpoint} (rate limited)`);
      }
      // Wait for the minimum interval before making the request
      await new Promise(resolve => setTimeout(resolve, MIN_REQUEST_INTERVAL));
    }

    // Create the actual request
    const requestPromise = this.executePublicRequest<T>(url, options);
    
    // Store the pending request
    pendingRequests.set(requestKey, requestPromise);

    // Clean up after request completes
    requestPromise.finally(() => {
      pendingRequests.delete(requestKey);
    });

    return requestPromise;
  }

  private async executeRequest<T>(
    url: string,
    options: RequestInit,
    requireAuth: boolean
  ): Promise<T> {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
      'x-api-key': getApiKey()
    };
    
    // Debug API key usage
    if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
      const apiKey = getApiKey();
      console.log('üîë API Key Configuration:', {
        hasApiKey: !!apiKey,
        apiKeyLength: apiKey?.length || 0,
        apiKeyPrefix: apiKey?.substring(0, 10) + '...' || 'none',
        fullApiKey: apiKey,
        headers: headers
      });
    }
    
    // Only set restricted headers in SSR (Node). Browsers block these.
    if (typeof window === 'undefined') {
      headers['User-Agent'] = `${ENV_CONFIG.APP_NAME}-Client/${ENV_CONFIG.APP_VERSION}`;
      headers['Origin'] = `${ENV_CONFIG.DEV_HTTPS ? 'https' : 'http'}://localhost:${ENV_CONFIG.PORT}`;
    }

    // Add JWT token if required and available
    if (requireAuth) {
      const authHeaders = this.jwtAuth.getAuthHeaders();
      Object.assign(headers, authHeaders);
    }

    const config: RequestInit = {
      method: 'GET',
      headers,
      credentials: 'include',
      ...options
    };

    const tryFetch = async (url: string): Promise<Response> => {
      if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
        console.log(`üåê API Request: ${url}`);
      }
      return fetch(url, config);
    };

    try {
      const response = await tryFetch(url);
      if (response.ok) {
        const data = await response.json();
        if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
          console.log(`‚úÖ API Success (${url}):`, data);
        }
        // Special debugging for locations
        if (url.includes('/v0/locations')) {
          console.log('üîß Locations API response details:', {
            url,
            status: response.status,
            dataType: typeof data,
            hasLocations: !!(data && data.locations),
            hasServiceTypes: !!(data && data.serviceTypes),
            dataKeys: data ? Object.keys(data) : []
          });
        }
        return data;
      } else {
        const errorMessage = await this.handleErrorResponse(response);
        throw new Error(errorMessage);
      }
    } catch (error) {
      if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
        console.error(`‚ùå API Error (${url}):`, error);
      }
      // Special debugging for locations errors
      if (url.includes('/v0/locations')) {
        console.error('üîß Locations API error details:', {
          url,
          error: error instanceof Error ? error.message : error,
          errorType: typeof error
        });
      }
      
      // Extract endpoint from URL for error handling
      const endpoint = url.replace(ENV_CONFIG.API_URL, '');
      
      // Check if it's a 503 error and handle it appropriately
      if (error instanceof Error && error.message.includes('503')) {
        console.warn(`‚ö†Ô∏è API returned 503 - Service Unavailable: ${endpoint}`);
        handleApiError(error, endpoint, {
          context: 'APIsw Service',
          showModal: false, // Let page controllers handle modal display
          logError: true
        });
        
        // Show modal for 503 errors
        this.showApiFailureModal([endpoint], true);
        throw new Error(`${endpoint} temporarily unavailable (503)`);
      }
      
      // Handle other errors without modal (let page controllers handle it)
      handleApiError(error, endpoint, {
        context: 'APIsw Service',
        showModal: false, // Let page controllers handle modal display
        logError: true
      });
      
      throw error;
    }
  }

  private async executePublicRequest<T>(
    url: string,
    options: RequestInit = {}
  ): Promise<T> {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
      'x-api-key': getApiKey()
    };
    
    // Debug API key usage
    if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
      const apiKey = getApiKey();
      console.log('üîë Public API Key Configuration:', {
        hasApiKey: !!apiKey,
        apiKeyLength: apiKey?.length || 0,
        apiKeyPrefix: apiKey?.substring(0, 10) + '...' || 'none',
        fullApiKey: apiKey,
        headers: headers
      });
    }
    
    // Only set restricted headers in SSR (Node). Browsers block these.
    if (typeof window === 'undefined') {
      headers['User-Agent'] = `${ENV_CONFIG.APP_NAME}-Client/${ENV_CONFIG.APP_VERSION}`;
      headers['Origin'] = `${ENV_CONFIG.DEV_HTTPS ? 'https' : 'http'}://localhost:${ENV_CONFIG.PORT}`;
    }

    const config: RequestInit = {
      method: 'GET',
      headers,
      credentials: 'include',
      ...options
    };

    const tryFetch = async (url: string): Promise<Response> => {
      if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
        console.log(`üåê Public API Request: ${url}`);
      }
      return fetch(url, config);
    };

    try {
      const response = await tryFetch(url);
      if (response.ok) {
        const data = await response.json();
        if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
          console.log(`‚úÖ Public API Success (${url}):`, data);
        }
        return data;
      } else {
        const errorMessage = await this.handlePublicErrorResponse(response);
        throw new Error(errorMessage);
      }
    } catch (error) {
      if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
        console.error(`‚ùå Public API Error (${url}):`, error);
      }
      throw error;
    }
  }

  async handlePublicErrorResponse(response: Response): Promise<string> {
    try {
      const errorData = await response.json();
      const errorMessage = errorData.message || response.statusText;
      
      // Handle 503 errors for public APIs - don't redirect, just return error
      if (response.status === 503) {
        if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
          console.warn('‚ö†Ô∏è Public API returned 503 - Service Unavailable');
        }
        return `HTTP 503: ${errorMessage}`;
      }
      
      // Handle other errors normally
      return `HTTP ${response.status}: ${errorMessage}`;
    } catch {
      return `HTTP ${response.status}: ${response.statusText}`;
    }
  }

  async handleErrorResponse(response: Response): Promise<string> {
    try {
      const errorData = await response.json();
      const errorMessage = errorData.message || response.statusText;
      
      // Handle 503 Service Unavailable specifically
      if (response.status === 503) {
        console.warn('‚ö†Ô∏è API returned 503 - Service Unavailable');
        const endpoint = response.url.replace(ENV_CONFIG.API_URL, '');
        const error = new Error(`HTTP 503: ${errorMessage}`);
        handleApiError(error, endpoint, {
          context: 'APIsw Service',
          showModal: false, // Let page controllers handle modal display
          logError: true
        });
        return `Service temporarily unavailable (503): ${errorMessage}`;
      }
      
      // Handle authentication errors (403) - redirect to signin
      if (response.status === 403) {
        if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
          console.warn('üîê Authentication failed, redirecting to signin');
        }
        this.redirectToSignin();
        return `Authentication required: ${errorMessage}`;
      }
      
      // Handle rate limiting specifically
      if (response.status === 429 || errorMessage.includes('Too many requests')) {
        if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
          console.warn('‚ö†Ô∏è Rate limited by backend. Consider enabling development API override.');
        }
        return `Rate limited: ${errorMessage}`;
      }
      
      return `HTTP ${response.status}: ${errorMessage}`;
    } catch {
      // Handle 503 even when JSON parsing fails
      if (response.status === 503) {
        console.warn('‚ö†Ô∏è API returned 503 - Service Unavailable (no JSON response)');
        const endpoint = response.url.replace(ENV_CONFIG.API_URL, '');
        const error = new Error(`HTTP 503: ${response.statusText}`);
        handleApiError(error, endpoint, {
          context: 'APIsw Service',
          showModal: false, // Let page controllers handle modal display
          logError: true
        });
        return `Service temporarily unavailable (503): ${response.statusText}`;
      }
      
      return `HTTP ${response.status}: ${response.statusText}`;
    }
  }

  private redirectToSignin(): void {
    try {
      const signinHost = updateSigninHost();
      if (typeof window !== 'undefined' && signinHost) {
        console.log('üîê Redirecting to signin:', signinHost);
        window.location.href = signinHost;
      }
    } catch (error) {
      console.error('‚ùå Failed to redirect to signin:', error);
    }
  }

  // =================================================================
  // AUTHENTICATION METHODS
  // =================================================================

  async login(email: string, password: string): Promise<any> {
    try {
      const response = await this.makeRequest<any>(API_ENDPOINTS.AUTH.LOGIN, {
        method: 'POST',
        body: JSON.stringify({ email, password })
      });

      if (response && response.success && response.token) {
        // Store JWT token with expiration
        const expiresAt = Date.now() + (response.expiresIn || 3600000); // Default 1 hour
        this.jwtAuth.setToken({
          token: response.token,
          expiresAt,
          user: response.user
        });

        if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
          console.log('üîê Login successful, JWT token stored');
        }
      }

      return response;
    } catch (error) {
      if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
        console.error('üîê Login failed:', error);
      }
      throw error;
    }
  }

  async logout(): Promise<void> {
    try {
      // Call logout endpoint to invalidate token on server
      await this.makeRequest(API_ENDPOINTS.AUTH.LOGOUT, {
        method: 'POST'
      }, true);
    } catch (error) {
      if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
        console.warn('‚ö†Ô∏è Server logout failed, but clearing local data:', error);
      }
    } finally {
      // Always clear local token
      this.jwtAuth.clearToken();
    }
  }

  async checkAuthStatus(): Promise<any> {
    // Check cache first
    const cached = apiCache.getCachedApiResponse<any>(API_ENDPOINTS.AUTH.STATUS);
    if (cached) {
      console.log('‚úÖ Using cached auth status data');
      return cached;
    }

    try {
      const result = await this.makeRequest(API_ENDPOINTS.AUTH.STATUS, {}, true);
      
      // Cache the successful response for 2 minutes (auth status changes frequently)
      if (result) {
        apiCache.cacheApiResponse(API_ENDPOINTS.AUTH.STATUS, result, 2 * 60 * 1000);
        console.log('üì¶ Cached auth status data');
      }
      
      return result;
    } catch (error) {
      return { success: false, message: 'Not authenticated' };
    }
  }

  // =================================================================
  // BATCH API METHODS (Load multiple endpoints at once)
  // =================================================================

  async loadInitialData(): Promise<{
    nav: any;
    services: any;
    authStatus: any;
  }> {
    try {
      if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
        console.log('üöÄ Loading initial data (batch request)...');
      }

      // Load all initial data concurrently
      const [navData, servicesData, authStatus] = await Promise.allSettled([
        this.getNav(),
        this.getServices(),
        this.checkAuthStatus()
      ]);

      const result = {
        nav: navData.status === 'fulfilled' ? navData.value : null,
        services: servicesData.status === 'fulfilled' ? servicesData.value : null,
        authStatus: authStatus.status === 'fulfilled' ? authStatus.value : null
      };

      if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
        console.log('‚úÖ Initial data loaded:', {
          nav: !!result.nav,
          services: !!result.services,
          authStatus: !!result.authStatus
        });
      }

      return result;
    } catch (error) {
      if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
        console.error('‚ùå Failed to load initial data:', error);
      }
      throw error;
    }
  }

  // =================================================================
  // PUBLIC CONTENT ENDPOINTS (No auth required)
  // =================================================================

  async getNav(): Promise<any> {
    // Check cache first
    const cached = apiCache.getCachedApiResponse<any>(API_ENDPOINTS.PRIVATE.NAV);
    if (cached) {
      console.log('‚úÖ Using cached navigation data');
      return cached;
    }

    // If not cached, make API call
    const result = await this.makeRequest(API_ENDPOINTS.PRIVATE.NAV);
    
    // Cache the successful response for 10 minutes
    if (result) {
      apiCache.cacheApiResponse(API_ENDPOINTS.PRIVATE.NAV, result, 10 * 60 * 1000);
      console.log('üì¶ Cached navigation data');
    }
    
    return result;
  }

  async getServices(): Promise<any> {
    // Check cache first
    const cached = apiCache.getCachedApiResponse<any>(API_ENDPOINTS.PUBLIC.SERVICES);
    if (cached) {
      console.log('‚úÖ Using cached services data');
      return cached;
    }

    // If not cached, make API call
    console.log('üîß APIsw.getServices() called - fetching from:', API_ENDPOINTS.PUBLIC.SERVICES);
    const result = await this.makeRequest(API_ENDPOINTS.PUBLIC.SERVICES);
    
    // Cache the successful response for 10 minutes
    if (result) {
      apiCache.cacheApiResponse(API_ENDPOINTS.PUBLIC.SERVICES, result, 10 * 60 * 1000);
      console.log('üì¶ Cached services data');
    }
    
    console.log('üîß APIsw.getServices() response:', {
      hasData: !!result,
      hasServices: !!(result && (result as any).services),
      servicesCount: (result as any)?.services?.length || 0
    });
    return result;
  }

  async checkHealth(): Promise<any> {
    // Check cache first
    const cached = apiCache.getCachedApiResponse<any>('/v0/health');
    if (cached) {
      console.log('‚úÖ Using cached health check data');
      return cached;
    }

    // If not cached, make API call
    const result = await this.makeRequest('/v0/health');
    
    // Cache the successful response for 30 seconds (health checks frequently)
    if (result) {
      apiCache.cacheApiResponse('/v0/health', result, 30 * 1000);
      console.log('üì¶ Cached health check data');
    }
    
    return result;
  }

  // =================================================================
  // PUBLIC DATA SERVICES (No authentication required)
  // =================================================================

  async getReferral(): Promise<any> {
    return await this.makeRequest(API_ENDPOINTS.PUBLIC.REFERRAL);
  }

  async getBlog(): Promise<any> {
    return await this.makeRequest(API_ENDPOINTS.PUBLIC.BLOG);
  }

  async getReviews(): Promise<any> {
    return await this.makeRequest(API_ENDPOINTS.PUBLIC.REVIEWS);
  }

  async getLocations(): Promise<any> {
    // Check cache first
    const cached = apiCache.getCachedApiResponse<any>(API_ENDPOINTS.PUBLIC.LOCATIONS);
    if (cached) {
      console.log('‚úÖ Using cached locations data');
      return cached;
    }

    // If not cached, make API call
    console.log('üîß APIsw.getLocations() called - fetching from:', API_ENDPOINTS.PUBLIC.LOCATIONS);
    const result = await this.makeRequest(API_ENDPOINTS.PUBLIC.LOCATIONS);
    
    // Cache the successful response for 15 minutes (locations change infrequently)
    if (result) {
      apiCache.cacheApiResponse(API_ENDPOINTS.PUBLIC.LOCATIONS, result, 15 * 60 * 1000);
      console.log('üì¶ Cached locations data');
    }
    
    console.log('üîß APIsw.getLocations() response:', {
      hasData: !!result,
      hasLocations: !!(result && (result as any).locations),
      hasServiceTypes: !!(result && (result as any).serviceTypes),
      locationsCount: (result as any)?.locations?.length || 0,
      serviceTypesCount: (result as any)?.serviceTypes?.length || 0
    });
    return result;
  }

  async getSupplies(): Promise<any> {
    // Check cache first
    const cached = apiCache.getCachedApiResponse<any>(API_ENDPOINTS.PUBLIC.SUPPLIES);
    if (cached) {
      console.log('‚úÖ Using cached supplies data');
      return cached;
    }

    // If not cached, make API call
    console.log('üîß APIsw.getSupplies() called - fetching from:', API_ENDPOINTS.PUBLIC.SUPPLIES);
    const result = await this.makeRequest(API_ENDPOINTS.PUBLIC.SUPPLIES);
    
    // Cache the successful response for 10 minutes
    if (result) {
      apiCache.cacheApiResponse(API_ENDPOINTS.PUBLIC.SUPPLIES, result, 10 * 60 * 1000);
      console.log('üì¶ Cached supplies data');
    }
    
    console.log('üîß APIsw.getSupplies() response:', {
      hasData: !!result,
      hasSupplies: !!(result && (result as any).supplies),
      suppliesCount: (result as any)?.supplies?.length || 0,
      firstSupplyStructure: (result as any)?.supplies?.[0]
    });
    return result;
  }


  async getServiceAreas(): Promise<any> {
    return await this.makePublicRequest(API_ENDPOINTS.PUBLIC.SERVICE_AREAS);
  }



  async getAbout(): Promise<any> {
    return await this.makeRequest(API_ENDPOINTS.PUBLIC.ABOUT);
  }

  async getContact(): Promise<any> {
    return await this.makeRequest(API_ENDPOINTS.PUBLIC.CONTACT);
  }

  // =================================================================
  // PRIVATE DATA SERVICES (Require authentication)
  // =================================================================

  async getPrivateNav(): Promise<any> {
    return await this.makeRequest(API_ENDPOINTS.PRIVATE.NAV, {}, true);
  }

  async getPrivateServices(): Promise<any> {
    return await this.makeRequest(API_ENDPOINTS.PRIVATE.SERVICES, {}, true);
  }

  async getPrivateLocations(): Promise<any> {
    return await this.makeRequest(API_ENDPOINTS.PRIVATE.LOCATIONS, {}, true);
  }

  async getPrivateSupplies(): Promise<any> {
    return await this.makeRequest(API_ENDPOINTS.PRIVATE.SUPPLIES, {}, true);
  }

  async getPrivateReviews(): Promise<any> {
    return await this.makeRequest(API_ENDPOINTS.PRIVATE.REVIEWS, {}, true);
  }

  async getPrivateTestimonials(): Promise<any> {
    return await this.makeRequest(API_ENDPOINTS.PRIVATE.TESTIMONIALS, {}, true);
  }

  async getPrivateAbout(): Promise<any> {
    return await this.makeRequest(API_ENDPOINTS.PRIVATE.ABOUT, {}, true);
  }

  async getPrivateContact(): Promise<any> {
    return await this.makeRequest(API_ENDPOINTS.PRIVATE.CONTACT, {}, true);
  }

  async getPrivateReferral(): Promise<any> {
    return await this.makeRequest(API_ENDPOINTS.PRIVATE.REFERRAL, {}, true);
  }

  async getPrivateBlog(): Promise<any> {
    return await this.makeRequest(API_ENDPOINTS.PRIVATE.BLOG, {}, true);
  }

  // =================================================================
  // CONSOLIDATED PAGE API METHODS
  // =================================================================

  /**
   * Get all home page data in a single consolidated call
   * Returns an object with all home page data
   */
  async getHomePageData(): Promise<{
    services: any;
    recentMoves: any;
    testimonials: any;
    nav: any;
    authStatus: any;
  }> {
    console.log('üöÄ Loading consolidated home page data...');
    
    // Define all endpoints that will be called for home page
    const homePageEndpoints = [
      '/v0/services',
      '/v0/recentMoves', 
      '/v0/testimonials',
      '/v0/nav',
      '/auth/status'
    ];
    
    // Load all home page data concurrently
    const [services, recentMoves, testimonials, nav, authStatus] = await Promise.allSettled([
      this.makeRequest(API_ENDPOINTS.PRIVATE.SERVICES), // /v0/services
      this.makeRequest('/v0/recentMoves'), // /v0/recentMoves  
      this.makeRequest(API_ENDPOINTS.PRIVATE.TESTIMONIALS), // /v0/testimonials
      this.makeRequest(API_ENDPOINTS.PRIVATE.NAV), // /v0/nav
      this.checkAuthStatus()
    ]);

    const result = {
      services: services.status === 'fulfilled' ? services.value : null,
      recentMoves: recentMoves.status === 'fulfilled' ? recentMoves.value : null,
      testimonials: testimonials.status === 'fulfilled' ? testimonials.value : null,
      nav: nav.status === 'fulfilled' ? nav.value : null,
      authStatus: authStatus.status === 'fulfilled' ? authStatus.value : null
    };

    // Check for failed endpoints and collect error details
    const failedEndpoints: string[] = [];
    const errors: any[] = [];

    if (services.status === 'rejected') {
      failedEndpoints.push('/v0/services');
      errors.push(services.reason);
    }
    if (recentMoves.status === 'rejected') {
      failedEndpoints.push('/v0/recentMoves');
      errors.push(recentMoves.reason);
    }
    if (testimonials.status === 'rejected') {
      failedEndpoints.push('/v0/testimonials');
      errors.push(testimonials.reason);
    }
    if (nav.status === 'rejected') {
      failedEndpoints.push('/v0/nav');
      errors.push(nav.reason);
    }
    if (authStatus.status === 'rejected') {
      failedEndpoints.push('/auth/status');
      errors.push(authStatus.reason);
    }

    // If any endpoints failed, throw a comprehensive error
    if (failedEndpoints.length > 0) {
      const primaryError = errors[0];
      const errorMessage = `Home page API failed - attempted endpoints: ${homePageEndpoints.join(', ')}, failed: ${failedEndpoints.join(', ')}`;
      
      console.error('‚ùå Consolidated home page data failed:', {
        attemptedEndpoints: homePageEndpoints,
        failedEndpoints,
        primaryError: primaryError?.message || 'Unknown error'
      });

      // Create a comprehensive error with all failed endpoints
      const comprehensiveError = new Error(errorMessage);
      (comprehensiveError as any).failedEndpoints = failedEndpoints;
      (comprehensiveError as any).attemptedEndpoints = homePageEndpoints;
      (comprehensiveError as any).primaryError = primaryError;
      
      throw comprehensiveError;
    }

    console.log('‚úÖ Consolidated home page data loaded:', {
      services: !!result.services,
      recentMoves: !!result.recentMoves,
      testimonials: !!result.testimonials,
      nav: !!result.nav,
      authStatus: !!result.authStatus
    });

    return result;
  }

  /**
   * Get all about page data in a single consolidated call
   * Returns an object with all about page data
   */
  async getAboutPageData(): Promise<{
    about: any;
    totalMovesCount: number;
  }> {
    try {
      console.log('üöÄ Loading consolidated about page data...');
      
      // Load about page data only (no navigation)
      const [about, totalMovesCount] = await Promise.allSettled([
        this.makeRequest(API_ENDPOINTS.PRIVATE.ABOUT), // /v0/about
        this.makeRequest('/v0/recentMoves/total') // /v0/recentMoves/total
      ]);

      const result = {
        about: about.status === 'fulfilled' ? about.value : null,
        totalMovesCount: totalMovesCount.status === 'fulfilled' ? (totalMovesCount.value as number) : 500
      };

      console.log('‚úÖ Consolidated about page data loaded:', {
        about: !!result.about,
        totalMovesCount: result.totalMovesCount
      });

      return result;
    } catch (error) {
      console.error('‚ùå Failed to load consolidated about page data:', error);
      throw error;
    }
  }

  /**
   * Get all contact page data in a single consolidated call
   * Returns an object with all contact page data
   */
  async getContactPageData(): Promise<{
    contact: any;
  }> {
    try {
      console.log('üöÄ Loading consolidated contact page data...');
      
      // Load contact page data only (no navigation)
      const contact = await this.makeRequest(API_ENDPOINTS.PRIVATE.CONTACT); // /v0/contact

      const result = {
        contact: contact
      };

      console.log('‚úÖ Consolidated contact page data loaded:', {
        contact: !!result.contact
      });

      return result;
    } catch (error) {
      console.error('‚ùå Failed to load consolidated contact page data:', error);
      throw error;
    }
  }

  // =================================================================
  // MODAL MANAGEMENT METHODS
  // =================================================================

  /**
   * Show the API failure modal with specific error details
   */
  showApiFailureModal(failedEndpoints: string[], is503Error: boolean = false, onClose?: () => void): void {
    // Only show failed endpoints, remove duplicates
    const uniqueEndpoints = Array.from(new Set(failedEndpoints));
    
    this.modalState = {
      isVisible: true,
      failedEndpoints: uniqueEndpoints, // Only unique failed endpoints
      is503Error,
      onClose: onClose || null
    };
    
    // Notify all listeners that modal state has changed
    this.notifyModalStateListeners();
    
    if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
      console.log('üîß APIsw: Showing API failure modal:', {
        originalFailedEndpoints: failedEndpoints,
        uniqueEndpoints,
        is503Error,
        hasOnClose: !!onClose,
        currentPage: this.currentPageName,
        allTrackedCalls: this.getTrackedApiCalls()
      });
    }
  }

  /**
   * Hide the API failure modal
   */
  hideApiFailureModal(): void {
    this.modalState = {
      isVisible: false,
      failedEndpoints: [],
      is503Error: false,
      onClose: null
    };
    
    // Notify all listeners that modal state has changed
    this.notifyModalStateListeners();
    
    if (this.isDevMode && !ENV_CONFIG.REDUCE_LOGGING) {
      console.log('üîß APIsw: Hiding API failure modal');
    }
  }

  /**
   * Get current modal state
   */
  getModalState() {
    return { ...this.modalState };
  }

  /**
   * Get the ApiFailureModal component with current state
   * This method returns the modal state for use by React components
   */
  getApiFailureModalProps() {
    return {
      isVisible: this.modalState.isVisible,
      onClose: () => {
        this.hideApiFailureModal();
        if (this.modalState.onClose) {
          this.modalState.onClose();
        }
      },
      failedEndpoints: this.modalState.failedEndpoints,
      is503Error: this.modalState.is503Error
    };
  }


  /**
   * Add a listener for modal state changes
   */
  addModalStateListener(listener: () => void): void {
    this.modalStateListeners.add(listener);
  }

  /**
   * Remove a listener for modal state changes
   */
  removeModalStateListener(listener: () => void): void {
    this.modalStateListeners.delete(listener);
  }

  /**
   * Notify all listeners that modal state has changed
   */
  private notifyModalStateListeners(): void {
    this.modalStateListeners.forEach(listener => {
      try {
        listener();
      } catch (error) {
        console.error('Error in modal state listener:', error);
      }
    });
  }

  // =================================================================
  // API CALL TRACKING METHODS
  // =================================================================

  /**
   * Start tracking API calls for a specific page
   */
  startPageTracking(pageName: string): void {
    this.currentPageName = pageName;
    this.pageApiCalls = [];
    console.log(`üîß [API-TRACKING] Started tracking API calls for page: ${pageName}`);
  }

  /**
   * Track an API call
   */
  trackApiCall(endpoint: string): void {
    this.pageApiCalls.push(endpoint);
    console.log(`üîß [API-TRACKING] Tracked API call: ${endpoint} (Page: ${this.currentPageName})`);
    console.log(`üîß [API-TRACKING] Current tracked calls:`, this.pageApiCalls);
  }

  /**
   * Get all tracked API calls for current page
   */
  getTrackedApiCalls(): string[] {
    console.log(`üîß [API-TRACKING] Getting tracked calls:`, this.pageApiCalls);
    return Array.from(this.pageApiCalls);
  }

  /**
   * Get current page name
   */
  getCurrentPageName(): string {
    return this.currentPageName;
  }

  /**
   * Reset API call tracking
   */
  resetApiCallTracking(): void {
    this.pageApiCalls = [];
    this.currentPageName = '';
    console.log('üîß [API-TRACKING] Reset API call tracking');
  }

  // =================================================================
  // HEALTH CHECK MIDDLEWARE METHODS
  // =================================================================

  private healthStatus: 'unknown' | 'healthy' | 'unhealthy' = 'unknown';
  private healthCheckTime: number = 0;
  private readonly HEALTH_CHECK_CACHE_DURATION = 30000; // 30 seconds

  /**
   * Check health status and cache result
   */
  async checkHealthWithCache(): Promise<boolean> {
    const now = Date.now();
    
    // Use cached result if recent
    if (this.healthStatus !== 'unknown' && (now - this.healthCheckTime) < this.HEALTH_CHECK_CACHE_DURATION) {
      return this.healthStatus === 'healthy';
    }

    try {
      console.log('üè• [HEALTH-MIDDLEWARE] Checking API health status...');
      await this.checkHealth();
      this.healthStatus = 'healthy';
      this.healthCheckTime = now;
      console.log('‚úÖ [HEALTH-MIDDLEWARE] Health check passed');
      return true;
    } catch (error) {
      console.error('‚ùå [HEALTH-MIDDLEWARE] Health check failed:', error);
      this.healthStatus = 'unhealthy';
      this.healthCheckTime = now;
      this.trackApiCall('/v0/health');
      return false;
    }
  }

  /**
   * Express.js-style middleware for health check
   * If health check fails, records all attempted routes as 503
   */
  async healthCheckMiddleware(req: any, res: any, next: any): Promise<void> {
    const endpoint = req.url || req.path || '/unknown';
    
    // Track the attempted endpoint
    this.trackApiCall(endpoint);
    
    // Check health first
    const isHealthy = await this.checkHealthWithCache();
    
    if (!isHealthy) {
      // Health check failed - record all routes as failed
      console.log('üö® [HEALTH-MIDDLEWARE] Health check failed, recording all routes as 503');
      
      // Get all routes that would have been called for this page
      const allRoutes = this.getTrackedApiCalls();
      
      console.log('üîß [HEALTH-MIDDLEWARE] All tracked routes:', allRoutes);
      
      // Show modal with all failed routes including health
      const allFailedRoutes = ['/v0/health', ...allRoutes];
      console.log('üîß [HEALTH-MIDDLEWARE] All failed routes for modal:', allFailedRoutes);
      
      this.showApiFailureModal(allFailedRoutes, true);
      
      // Set 503 status and error
      res.statusCode = 503;
      res.status = 503;
      res.error = new Error(`Service Unavailable (503): Health check failed for ${endpoint}`);
      
      // Call next with error to stop the chain
      next(new Error(`Service Unavailable (503): Health check failed for ${endpoint}`));
      return;
    }
    
    // Health is good, continue to next middleware
    next();
  }

  /**
   * Express.js-style middleware that pre-tracks all routes for a page
   * This should be called before any health checks
   */
  preTrackRoutesMiddleware(routes: string[]): void {
    console.log('üîß [PRE-TRACK-MIDDLEWARE] Pre-tracking routes for page:', routes);
    routes.forEach(route => {
      this.trackApiCall(route);
      console.log(`üîß [PRE-TRACK-MIDDLEWARE] Tracked route: ${route}`);
    });
  }

  /**
   * Middleware function that checks health before making API calls
   * If health check fails, records all attempted routes as 503
   */
  async withHealthCheck<T>(
    endpoint: string, 
    apiCall: () => Promise<T>,
    allRoutes: string[] = []
  ): Promise<T> {
    // Track the attempted endpoint
    this.trackApiCall(endpoint);
    
    // Check health first
    const isHealthy = await this.checkHealthWithCache();
    
    if (!isHealthy) {
      // Health check failed - record all routes as failed
      console.log('üö® [HEALTH-MIDDLEWARE] Health check failed, recording all routes as 503');
      
      // Track all routes that would have been called
      allRoutes.forEach(route => {
        if (!this.pageApiCalls.includes(route)) {
          this.trackApiCall(route);
        }
      });
      
      // Show modal with all failed routes
      const allFailedRoutes = ['/v0/health', ...allRoutes];
      this.showApiFailureModal(allFailedRoutes, true);
      
      throw new Error(`Service Unavailable (503): Health check failed for ${endpoint}`);
    }
    
    // Health is good, proceed with API call
    try {
      return await apiCall();
    } catch (error) {
      console.error(`‚ùå [HEALTH-MIDDLEWARE] API call failed for ${endpoint}:`, error);
      throw error;
    }
  }

  // =================================================================
  // UTILITY METHODS
  // =================================================================

  async testConnection(): Promise<any> {
    try {
      const health = await this.checkHealth();
      return { 
        success: true, 
        data: health,
        apiUrl: ENV_CONFIG.API_URL,
        skipBackendCheck: ENV_CONFIG.SKIP_BACKEND_CHECK
      };
    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error',
        apiUrl: ENV_CONFIG.API_URL,
        skipBackendCheck: ENV_CONFIG.SKIP_BACKEND_CHECK
      };
    }
  }

  getConfig(): any {
    return {
      apiUrl: ENV_CONFIG.API_URL,
      devMode: this.isDevMode,
      skipBackendCheck: ENV_CONFIG.SKIP_BACKEND_CHECK,
      isAuthenticated: this.jwtAuth.isAuthenticated(),
      hasToken: !!this.jwtAuth.getToken(),
      appName: ENV_CONFIG.APP_NAME,
      appVersion: ENV_CONFIG.APP_VERSION,
      enableDevTools: ENV_CONFIG.ENABLE_DEV_TOOLS,
      reduceLogging: ENV_CONFIG.REDUCE_LOGGING,
      apiTimeout: ENV_CONFIG.API_TIMEOUT,
      cacheEnabled: ENV_CONFIG.CACHE_ENABLED,
      cacheTtl: ENV_CONFIG.CACHE_TTL,
      cacheMaxSize: ENV_CONFIG.CACHE_MAX_SIZE
    };
  }

  // JWT Authentication helpers
  isAuthenticated(): boolean {
    return this.jwtAuth.isAuthenticated();
  }

  getUser(): any {
    return this.jwtAuth.getUser();
  }

  getAuthHeaders(): Record<string, string> {
    return this.jwtAuth.getAuthHeaders();
  }

}

// =============================================================================
// SINGLETON INSTANCE
// =============================================================================

export const api = APIsw.getInstance();

// =============================================================================
// BACKWARD COMPATIBILITY EXPORTS
// =============================================================================

// Export individual functions for backward compatibility
export const login = (email: string, password: string) => api.login(email, password);
export const logout = () => api.logout();
export const checkAuthStatus = () => api.checkAuthStatus();
export const getNav = () => api.getNav();
export const getServices = () => api.getServices();
export const checkHealth = () => api.checkHealth();
export const getReferral = () => api.getReferral();
export const getBlog = () => api.getBlog();
export const getReviews = () => api.getReviews();
export const getLocations = () => api.getLocations();
export const getSupplies = () => api.getSupplies();
export const getAbout = () => api.getAbout();
export const getContact = () => api.getContact();
export const testConnection = () => api.testConnection();
export const getConfig = () => api.getConfig();
export const isAuthenticated = () => api.isAuthenticated();
export const getUser = () => api.getUser();
export const getAuthHeaders = () => api.getAuthHeaders();

// Export consolidated page data methods
export const getHomePageData = () => api.getHomePageData();
export const getAboutPageData = () => api.getAboutPageData();
export const getContactPageData = () => api.getContactPageData();

// Export API configuration functions
export { getApiKey, getSigninHost };

// Export environment configuration
export { ENV_CONFIG };

// Export modal management functions
export const getApiFailureModalProps = () => api.getApiFailureModalProps();
export const addModalStateListener = (listener: () => void) => api.addModalStateListener(listener);
export const removeModalStateListener = (listener: () => void) => api.removeModalStateListener(listener);

// Export API call tracking functions
export const startPageTracking = (pageName: string) => api.startPageTracking(pageName);
export const trackApiCall = (endpoint: string) => api.trackApiCall(endpoint);
export const getTrackedApiCalls = () => api.getTrackedApiCalls();
export const getCurrentPageName = () => api.getCurrentPageName();
export const resetApiCallTracking = () => api.resetApiCallTracking();

// Export health check middleware functions
export const checkHealthWithCache = () => api.checkHealthWithCache();
export const withHealthCheck = <T>(endpoint: string, apiCall: () => Promise<T>, allRoutes?: string[]) => api.withHealthCheck(endpoint, apiCall, allRoutes);
export const healthCheckMiddleware = (req: any, res: any, next: any) => api.healthCheckMiddleware(req, res, next);
export const preTrackRoutesMiddleware = (routes: string[]) => api.preTrackRoutesMiddleware(routes);

// Export API blocking functions
export const setApiBlocked = (isBlocked: boolean) => api.setApiBlocked(isBlocked);
export const getApiBlocked = () => api.getApiBlocked();

// Export health gate functions
export const resetHealthGate = () => api.resetHealthGate(); 